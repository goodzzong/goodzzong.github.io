---
layout: post
title: 클로저
name : goodzzong
date: 2018-09-05
categories: Javascript

tags: [Javascript]
comments: true
---

## 정의

클로저의 사전적 의미를 찾아보면 함수와 그함수가 선언될 당시의 환경정보 사이의 조합`(선언될 당시: 스코프)`이다.
더 풀어서 정리하자면 함수 내부에서 생성한 데이터와 그 유효범위로 인해 발생하는 특수한 `현상 / 상태` 이다.

전역변수 객체와 함수 변수객체, 그리고 해당 스코프영역에서의 없는 변수는 스코프 체인으로 찾아 접근 할 수 있다.
실행컨텍스트 스택에는 글로벌 부터 각각의 함수 실행컨텍스트까지 차곡차곡 쌓이게 된다. 그리고 실행이 완료된 실행컨텍스트들은 스택에서 제거가 된다. 이때 의문이 생긴다. 제거된 컨텍스트에 다시 접근하려 한다면 존재하지도 않는 컨텍스트를 리턴해야 하는 어처구니 없는 일이 벌어진다. 결국 이미 없어진 객체를 계속적으로 사용하게 되는 오류가 발생한다.

이러한 상황때문에 등장하게 되는 개념이 클로저이다.


예시로 설명하면 이렇다.

```js
function testFn() {

  var localVar = 10;

  function innerFn(innerParam) {
    alert(innerParam + localVar);
  }

  return innerFn;
}

var someFn = testFn();
someFn(20); // 30
```

이 예제의 localVar는 innerFn 함수가 사용하는 자유 변수다.
스택 지향 모델이라고 가정해보자. testFn 함수를 종료하면서 모든 지역 변수를 스택에서 제거할 것이고, 이 때문에 외부에서 innerFn 함수를 실행하려고 할 때 에러가 발생할 것이다.

게다가 위의 예처럼 innerFn 함수를 반환하는 것은 아예 불가능하다. innerFn 함수가 testFn의 지역에 있기 때문에 testFn 함수가 종료되면서 innerFn 함수도 사라진다. 동적 스코프를 이용하는 시스템에서 함수를 전달인자로 넘길 때 함수 객체가 갖고 있는 또 다른 문제가 발생한다 .

> 자유 변수는 함수가 사용하는 변수 중, 파라미터와 함수의 지역 변수를 제외한 변수를 말한다.

```js
var z = 10;

function foo() {
  alert(z);
}

foo(); // 10 - 정적 스코프와 동적 스코프를 둘다 사용

(function () {

  var z = 20;
  foo(); // 10 – 정적 스코프, 20 – 동적 스코프

})();

// 전달인자로 foo를 넘기는 것과 같다.
(function (funArg) {

  var z = 30;
  funArg(); // 10 – 정적 스코프, 30 – 동적 스코프

})(foo);
```

동적 스코프인 경우에는 동적(활동적) 스택을 이용해 변수를 처리한다. 결국 함수를 생성할 때 함수에 저장한 정적(어휘적) 스코프 체인이 아닌, 현재 실행중인 함수의 동적 스코프 체인에서 자유 변수를 찾는다. 이는 모호한 상황을 만든다. 예를 들어 지역 변수를 스택에서 제거하는 이전 예제와는 달리  z가 계속해서 살아있는 경우, 콘텍스트의 z를 사용해야할지 아니면 스코프의 z를 사용해야할지 알 수 없다.

지금까지 함수가 함수를 값으로 반환하거나(upward funarg), 함수를 다른 함수에 전달인자로 전달할 때(downward funarg) 생기는 2가지 유형의 함수 전달인자 문제(funarg problem)를 알아봤다. 클로저는 이러한 문제(및 서브타입)를 해결하기 위해 나온 개념이다.

> 보통 자바스크립트는 함수가 정의된 시점의 환경을 기준으로 하는 정직은 스코프이다. 동적 스코프는 프로그램의 런타임 도중의 실행 컨텍스트나 호출컨텍스트에 의해 결정된다.


## 클로저로 해결

### upward funargs problem

 이 문제는 함수가 다른 함수를 리턴하고 이미 선언된 변수를 사용하면서 발생한다. 다시 말해 변수를 찾기 위해서 이미 사라진 변수를 찾으로 부모컨텍스트로 접근을 하면서 발생한다.
 이를 해결하기위해 각 함수가 생성 되는 순간, 다시말해 컨텍스트가 생성되는 순간에 [[Scope]]프로퍼티를 사용해서 부모의 정보를 저장해 둔다. 그리곤 새로운 실행객체정보와 부모의 정보를 담은 [[Scope]]정보를 조합해서 새로운 스코프체인정보를 생성한다.

> Scope Chain = Activation object + [[Scope]]

 이렇게 하면 부모 컨텍스트가 제거가 된 후에도 상위변수들을 참조 할 수 있다.

 ```js
function foo(){
     var x = 10;
     return function bar(){
     c     onsole.log(x)
     }
}
var returnFunction = foo();
var x =20;
returnFunction();
-> 10

 ```
이와 같은 스코프를 static 또는 lexical 스코프라고 부른다.

### downward funargs problem

이경우에는 첫번째와 다르게 부모 컨택스트는 존재합니다. 하지만 내부 함수가 어떤 변수를 사용해야 하는지 애매 모호한 경우가 있습니다. 정적으로 함수가 생성이 될때 만들어진 컨택스트의 변수 정보를 사용할것인지 아니면 실행시점에 동적으로 생성된 컨택스트의 변수 정보를 사용할것인지 하나를 선택해야 하는 상황이 발생합니다.
자바스크립트는 이 경우에는 무조건 정적으로 즉, 함수가 생성되는 시점에 저장한 정보를 사용하는것으로 정해두었습니다.

 ```js
var x = 10;
function foo(){
     console.log(x)
}

(function(funArg){
     var x = 20;
     funArg();
})(foo);

 ```
 이경우에 funArg() 함수는 어떤 x를 사용해야하는지 애매모호할수 있으나 함수가 실행되는 시점이 아닌 생성이 되는 시점에 참조하는 x값을 그대로 사용하게 됩니다. 결과는 10이 될것입니다.

자바스크립트는 [[Scope]]라는 프로퍼티를 통해 클로저를 완벽하게 지원을 하고 있고 정적 스코프가 자바스크립트에서 클로저를 사용하는데 필수적인 요소라는 것입니다.

결국 클로저는 코드블럭과 statically / lexically 저장하고 있는 부모 스코프의 모든 정보의 조합의 개념입니다. 그렇기 때문에 함수는 자연스럽게 내부에서 부모의 변수들을 자연스럽게 접근을 할수 있습니다.

그리고 이는 이론적으로 봤을때는 자바스크립트의 모든 함수는 생성이 되는 순간 [[Scope]] 프로퍼티를 가지고 있기 때문에 함수는 곧 클로저와 같다고 생각해도 됩니다.

출처: http://yubylab.tistory.com/entry/자바스크립트-변수로-자바스크립트-이해하기 [Yuby's Lab.]